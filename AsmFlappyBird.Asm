.386
.model flat,stdcall
option casemap:none

include AsmFlappyBird.inc

.code

start:

	invoke GetModuleHandle,NULL
	mov    hInstance,eax
	invoke GetCommandLine
	mov		CommandLine,eax
	invoke InitCommonControls
	invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT
	invoke ExitProcess,eax

WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD
	LOCAL	wc:WNDCLASSEX
	LOCAL	msg:MSG

	mov		wc.cbSize,sizeof WNDCLASSEX
	mov		wc.style,CS_HREDRAW or CS_VREDRAW
	mov		wc.lpfnWndProc,offset WndProc
	mov		wc.cbClsExtra,NULL
	mov		wc.cbWndExtra,DLGWINDOWEXTRA
	push	hInst
	pop		wc.hInstance
	mov		wc.hbrBackground,COLOR_BTNFACE+1
	;mov		wc.lpszMenuName,IDM_MENU
	mov		wc.lpszClassName,offset ClassName
	invoke LoadIcon,NULL,IDI_APPLICATION
	mov		wc.hIcon,eax
	mov		wc.hIconSm,eax
	invoke LoadCursor,NULL,IDC_ARROW
	mov		wc.hCursor,eax
	invoke RegisterClassEx,addr wc
	invoke CreateDialogParam,hInstance,IDD_DIALOG,NULL,addr WndProc,NULL
	invoke ShowWindow,hWnd,SW_SHOWNORMAL
	invoke UpdateWindow,hWnd
	.while TRUE
		invoke GetMessage,addr msg,NULL,0,0
	  .BREAK .if !eax
		invoke TranslateMessage,addr msg
		invoke DispatchMessage,addr msg
	.endw
	mov		eax,msg.wParam
	ret

WinMain endp


PaintBoard proc uses ebx esi,hWin:HWND,hDC:HDC
	LOCAL	mDC:HDC
	LOCAL	hBmp:DWORD
	LOCAL	hOld:DWORD
	LOCAL	rect:RECT
	LOCAL	wRect:RECT
	LOCAL	xmax:DWORD
	LOCAL	buffer[32]:BYTE

	invoke CreateCompatibleDC,hDC
	mov		mDC,eax
	invoke CreateCompatibleBitmap,hDC,288,500
	invoke SelectObject,mDC,eax
	push	eax
	mov		rect.left,0
	mov		rect.top,0
	mov		rect.right,288
	mov		rect.bottom,500
	; Draw background
	invoke ImageList_Draw, bgIml, 0, mDC, 0, 0, ILD_TRANSPARENT
	
	; Draw words
	.if gStatus == 0
	    mov		wRect.left,0
	    mov		wRect.top,210
	    mov		wRect.right,288
	    mov		wRect.bottom,500
	    invoke SetBkMode,mDC,TRANSPARENT
	    invoke SetTextColor,mDC,0000000h
	    invoke wsprintfA,addr buffer,offset lastFmtStr,lPoint
	    invoke DrawText,mDC,addr buffer,-1,addr wRect,DT_CENTER
	    mov		wRect.top,235
	    invoke wsprintfA,addr buffer,offset maxFmtStr,maxPoint
	    invoke DrawText,mDC,addr buffer,-1,addr wRect,DT_CENTER
	    mov		wRect.top,260
	    invoke wsprintfA,addr buffer,offset startStr
	    invoke DrawText,mDC,addr buffer,-1,addr wRect,DT_CENTER
	.else
	    ; Draw tube here
	    push ebx
	    mov ebx, offset upTube
	    .if [ebx].OBJECT.x < 288 || [ebx].OBJECT.x <= -1
	        invoke ImageList_Draw, tubeIml, 0, mDC, [ebx].OBJECT.x, [ebx].OBJECT.y, ILD_TRANSPARENT
	    .endif
        add ebx, sizeof OBJECT
        .if [ebx].OBJECT.x < 288 || [ebx].OBJECT.x <= -1
	        invoke ImageList_Draw, tubeIml, 0, mDC, [ebx].OBJECT.x, [ebx].OBJECT.y, ILD_TRANSPARENT
	    .endif
 	    mov ebx, offset downTube
 	    ;mov eax, [ebx].OBJECT.x
 	    ;mov cPoint, eax
 	    .if [ebx].OBJECT.x < 288 || [ebx].OBJECT.x <= -1
	        invoke ImageList_Draw, tubeIml, 1, mDC, [ebx].OBJECT.x, [ebx].OBJECT.y, ILD_TRANSPARENT
	    .endif
        add ebx, sizeof OBJECT
        .if [ebx].OBJECT.x < 288 || [ebx].OBJECT.x <= -1
            invoke ImageList_Draw, tubeIml, 1, mDC, [ebx].OBJECT.x, [ebx].OBJECT.y, ILD_TRANSPARENT
        .endif
	    pop ebx
	
	    ; end draw tube
	    mov		wRect.left,0
	    mov		wRect.top,50
	    mov		wRect.right,288
	    mov		wRect.bottom,500
	    invoke SetBkMode,mDC,TRANSPARENT	    
	    invoke wsprintfA,addr buffer,offset fmtStr,cPoint
	    invoke SetTextColor,mDC,0ffffffh
	    invoke DrawText,mDC,addr buffer,-1,addr wRect,DT_CENTER
	    invoke SetTextColor,mDC,0000000h
	    mov		wRect.top,49
	    mov		wRect.right,286
	    invoke DrawText,mDC,addr buffer,-1,addr wRect,DT_CENTER
	.endif
		
	; Draw bottom
	mov eax, speed
	sub bottomX, eax
	.if bottomX < -47
	    mov bottomX, 0
	.endif
	invoke ImageList_Draw, barIml, 0, mDC, bottomX, bottomY, ILD_TRANSPARENT
	
	; Draw bird
	.if cflap < 1 && cflapDir == 3
	    mov cflapDir, 0
	.elseif cflap > 1 && cflapDir == 3
	    mov cflapDir, 1
	.elseif cflap < 1 || cflap > 1
	    mov cflapDir, 3
	.endif
	
	.if cflapDir==0
	    inc cflap
	.elseif cflapDir==1
	    dec cflap
	.endif
	
	invoke ImageList_Draw, birdIml, cflap, mDC, birdX, birdY, ILD_TRANSPARENT
	
	invoke GetClientRect,hWin,addr rect
	invoke StretchBlt,hDC,0,0,rect.right,rect.bottom,mDC,0,0,288,500,SRCCOPY
	pop		eax
	invoke SelectObject,mDC,eax
	invoke DeleteObject,eax
	invoke DeleteDC,mDC
	ret

PaintBoard endp


BoardProc proc hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
	LOCAL	ps:PAINTSTRUCT

	.if uMsg==WM_PAINT
		invoke BeginPaint,hWin,addr ps
		invoke PaintBoard,hWin,ps.hdc
		invoke EndPaint,hWin,addr ps
		xor		eax,eax
		ret
	.endif 
	invoke CallWindowProc,OldBoardProc,hWin,uMsg,wParam,lParam
	ret

BoardProc endp


Random proc uses ecx edx,range:DWORD

    inc rseed
	mov eax, rseed
	mov ecx, 23
	mul ecx
	add eax, 7
	and eax, 0FFFFFFFFh
	ror eax, 1
	xor eax, rseed
	mov rseed, eax
	mov ecx, range
	xor edx, edx
	div ecx
	mov eax, edx
	ret

Random endp


SetupDie proc uses eax,hWin:DWORD

    mov eax, cPoint
    mov cPoint, 0
    mov lPoint, eax
    .if eax > maxPoint
        mov maxPoint, eax  
    .endif
    mov gStatus, 0
    
    mov birdX, 127
    mov birdY, 168
    
    invoke InvalidateRect,hWin,NULL,TRUE
 
    ret
SetupDie endp


SetupFly proc uses eax
    inc rseed
    ; set bird
    mov birdX, 63
    mov birdY, 200
    mov eax, jumpAc
    mov birdAc, eax
    ; set tube
    push ebx
    push edx
    mov ebx, offset upTube
    mov edx, offset downTube
    mov [ebx].OBJECT.x, 576
    mov [edx].OBJECT.x, 576
    invoke Random, 160
    add eax, 195
    mov [edx].OBJECT.y, eax
    sub eax, 450
    mov [ebx].OBJECT.y, eax
    add ebx, sizeof OBJECT
    add edx, sizeof OBJECT
    mov [ebx].OBJECT.x, 756
    mov [edx].OBJECT.x, 756
    invoke Random, 160
    add eax, 195
    mov [edx].OBJECT.y, eax
    sub eax, 450
    mov [ebx].OBJECT.y, eax
    pop edx
    pop ebx
    mov addedFlag, 0
    ret
SetupFly endp


TimerProc proc hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM

    .if gStatus == 1
        mov eax, birdAc
        add eax, gravityAc
        .if eax > birdMaxAc && eax < 10000
            mov eax, birdMaxAc
        .endif
        mov birdAc, eax
        add eax, birdY
        .if eax > 10000
            mov eax, 0
        .endif
        .if eax > birdBottom ; touch the ground, failed
            invoke SetupDie, hBoard
            mov gStatus, 0
        .else
            mov birdY, eax
        .endif
        push ebx
        push edx
        mov ebx, offset downTube
        mov eax, [ebx].OBJECT.x
        .if eax < 63 && addedFlag == 0
            inc cPoint
            mov addedFlag, 1
        .endif
        .if eax > 11 && eax < 97
            mov eax, [ebx].OBJECT.y
            sub eax, birdY
            .if eax < 24 || eax > 130 
                invoke SetupDie, hBoard
                mov gStatus, 0
            .endif
        .endif
        
        mov ebx, offset upTube
        mov edx, offset downTube
        .if [ebx].OBJECT.x < -54 && [ebx].OBJECT.x > 10000
            mov eax, ebx
            add eax, sizeof OBJECT
            mov ecx, [eax].OBJECT.x
            mov [ebx].OBJECT.x, ecx
            mov ecx, [eax].OBJECT.y
            mov [ebx].OBJECT.y, ecx
            mov eax, edx
            add eax, sizeof OBJECT
            mov ecx, [eax].OBJECT.x
            mov [edx].OBJECT.x, ecx
            mov ecx, [eax].OBJECT.y
            mov [edx].OBJECT.y, ecx
            
            mov eax, [edx].OBJECT.x
            add eax, 180
            add ebx, sizeof OBJECT
            add edx, sizeof OBJECT
            mov [ebx].OBJECT.x, eax
            mov [edx].OBJECT.y, eax
            invoke Random, 160
            add eax, 195
            mov [edx].OBJECT.y, eax
            sub eax, 450
            mov [ebx].OBJECT.y, eax
            
            mov addedFlag, 0
        .endif
        mov ecx, 2
        mov ebx, offset upTube
        mov edx, offset downTube
        .while ecx
            mov eax, [ebx].OBJECT.x
            sub eax, speed
            mov [ebx].OBJECT.x, eax
            mov [edx].OBJECT.x, eax
            add ebx, sizeof OBJECT
            add edx, sizeof OBJECT
            dec ecx
        .endw
        pop edx
        pop ebx
    .endif
	invoke InvalidateRect,hBoard,NULL,TRUE
	ret

TimerProc endp


InitParam proc
    
    mov speed, 4
    mov bottomY, 387
    mov birdMaxAc, 10
    mov birdBottom, 366
    mov gravityAc, 2
    mov jumpAc, -14
    mov cflap, 1
    ret

InitParam endp


WndProc proc hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
    LOCAL	hBmp:DWORD

	mov		eax,uMsg
	.if eax==WM_INITDIALOG
		push	hWin
		pop		hWnd
		; Load background image
		invoke ImageList_Create,288,500,ILC_COLOR16,1,0
		mov		bgIml,eax
		invoke LoadBitmap,hInstance,IDB_BG
		mov		hBmp,eax
		invoke ImageList_AddMasked,bgIml,hBmp,0
		invoke DeleteObject,hBmp
		; Load tube image
		invoke ImageList_Create,52,320,ILC_COLOR16 or ILC_MASK,2,2
		mov		tubeIml,eax
		invoke LoadBitmap,hInstance,IDB_TUBE
		mov		hBmp,eax
		invoke ImageList_AddMasked,tubeIml,hBmp,0
		invoke DeleteObject,hBmp
		; Load bird image
		invoke ImageList_Create,34,24,ILC_COLOR16 or ILC_MASK,3,3
		mov		birdIml,eax
		invoke LoadBitmap,hInstance,IDB_BIRD
		mov		hBmp,eax
		invoke ImageList_AddMasked,birdIml,hBmp,0
		invoke DeleteObject,hBmp
		; Load bar image
		invoke ImageList_Create,336,112,ILC_COLOR16,1,0
		mov		barIml,eax
		invoke LoadBitmap,hInstance,IDB_BAR
		mov		hBmp,eax
		invoke ImageList_AddMasked,barIml,hBmp,0
		invoke DeleteObject,hBmp

		invoke GetDlgItem,hWin,IDC_BOARD
		mov		hBoard,eax
		invoke SetWindowLong,hBoard,GWL_WNDPROC,offset BoardProc
		mov		OldBoardProc,eax
		invoke InitParam
		invoke SetupDie, hBoard
		invoke SetTimer,hWin,200,MTIMER,offset TimerProc
	.elseif eax==WM_KEYDOWN
		mov		eax,wParam
		.if eax==VK_SPACE
			push	ebx
			.if gStatus == 0
			    mov gStatus, 1
			    invoke SetupFly
			.else
			    mov eax, jumpAc
			    mov birdAc, eax
			.endif
			pop		ebx
		.endif
	.elseif eax==WM_COMMAND
		mov		eax,wParam
		and		eax,0FFFFh
		.if eax==IDM_FILE_EXIT
			invoke SendMessage,hWin,WM_CLOSE,0,0
		.elseif eax==IDM_HELP_ABOUT
			invoke ShellAbout,hWin,addr AppName,addr AboutMsg,NULL
		.endif
;	.elseif eax==WM_SIZE
	.elseif eax==WM_CLOSE
		invoke DestroyWindow,hWin
	.elseif uMsg==WM_DESTROY
		invoke PostQuitMessage,NULL
	.else
		invoke DefWindowProc,hWin,uMsg,wParam,lParam
		ret
	.endif
	xor    eax,eax
	ret

WndProc endp

end start
